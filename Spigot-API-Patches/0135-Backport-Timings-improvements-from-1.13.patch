From 21141e9b6dc87b2ab8d7dacaff1b4d344e374e21 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 17 Oct 2018 21:58:27 -0400
Subject: [PATCH] Backport Timings improvements from 1.13


diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
index c2c2fb83..28d0954a 100644
--- a/src/main/java/co/aikar/timings/TimingHistory.java
+++ b/src/main/java/co/aikar/timings/TimingHistory.java
@@ -201,11 +201,11 @@ public class TimingHistory {
 
         @SuppressWarnings("unchecked")
         final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<EntityType, Counter>(EntityType.class), Counter.LOADER
+                new EnumMap<EntityType, Counter>(EntityType.class), k -> new Counter()
         ));
         @SuppressWarnings("unchecked")
         final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<Material, Counter>(Material.class), Counter.LOADER
+                new EnumMap<Material, Counter>(Material.class), k -> new Counter()
         ));
 
         static class RegionId {
@@ -335,13 +335,6 @@ public class TimingHistory {
 
     private static class Counter {
         private int count = 0;
-        @SuppressWarnings({"rawtypes", "SuppressionAnnotation", "Guava"})
-        static Function LOADER = new LoadingMap.Feeder<Counter>() {
-            @Override
-            public Counter apply() {
-                return new Counter();
-            }
-        };
         public int increment() {
             return ++count;
         }
diff --git a/src/main/java/co/aikar/timings/TimingIdentifier.java b/src/main/java/co/aikar/timings/TimingIdentifier.java
index 623dda49..636c7119 100644
--- a/src/main/java/co/aikar/timings/TimingIdentifier.java
+++ b/src/main/java/co/aikar/timings/TimingIdentifier.java
@@ -23,12 +23,13 @@
  */
 package co.aikar.timings;
 
-import com.google.common.base.Function;
 import co.aikar.util.LoadingMap;
-import co.aikar.util.MRUMapCache;
 
 import java.util.ArrayDeque;
 import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * <p>Used as a basis for fast HashMap key comparisons for the Timing Map.</p>
@@ -39,15 +40,8 @@ final class TimingIdentifier {
     /**
      * Holds all groups. Autoloads on request for a group by name.
      */
-    static final Map<String, TimingGroup> GROUP_MAP = MRUMapCache.of(
-        LoadingMap.newIdentityHashMap(new Function<String, TimingGroup>() {
-            @Override
-            public TimingGroup apply(String group) {
-                return new TimingGroup(group);
-            }
-        }, 64)
-    );
-    static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
+    static final Map<String, TimingGroup> GROUP_MAP = LoadingMap.of(new ConcurrentHashMap<>(64, .5F), TimingGroup::new);
+    private static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
     final String group;
     final String name;
     final TimingHandler groupHandler;
@@ -55,8 +49,8 @@ final class TimingIdentifier {
     private final int hashCode;
 
     TimingIdentifier(String group, String name, Timing groupHandler, boolean protect) {
-        this.group = group != null ? group.intern() : DEFAULT_GROUP.name;
-        this.name = name.intern();
+        this.group = group != null ? group: DEFAULT_GROUP.name;
+        this.name = name;
         this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
         this.protect = protect;
         this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
@@ -67,11 +61,9 @@ final class TimingIdentifier {
             return DEFAULT_GROUP;
         }
 
-        return GROUP_MAP.get(groupName.intern());
+        return GROUP_MAP.get(groupName);
     }
 
-    // We are using .intern() on the strings so it is guaranteed to be an identity comparison.
-    @SuppressWarnings("StringEquality")
     @Override
     public boolean equals(Object o) {
         if (o == null) {
@@ -79,7 +71,7 @@ final class TimingIdentifier {
         }
 
         TimingIdentifier that = (TimingIdentifier) o;
-        return group == that.group && name == that.name;
+        return Objects.equals(group, that.group) && Objects.equals(name, that.name);
     }
 
     @Override
@@ -89,8 +81,8 @@ final class TimingIdentifier {
 
     static class TimingGroup {
 
-        private static int idPool = 1;
-        final int id = idPool++;
+        private static AtomicInteger idPool = new AtomicInteger(1);
+        final int id = idPool.getAndIncrement();
 
         final String name;
         ArrayDeque<TimingHandler> handlers = new ArrayDeque<TimingHandler>(64);
@@ -98,5 +90,18 @@ final class TimingIdentifier {
         private TimingGroup(String name) {
             this.name = name;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            TimingGroup that = (TimingGroup) o;
+            return id == that.id;
+        }
+
+        @Override
+        public int hashCode() {
+            return id;
+        }
     }
 }
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
index 58ed35e0..3b440190 100644
--- a/src/main/java/co/aikar/timings/TimingsManager.java
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -23,45 +23,35 @@
  */
 package co.aikar.timings;
 
-import com.google.common.base.Function;
+import co.aikar.util.LoadingMap;
 import com.google.common.collect.EvictingQueue;
 import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.java.PluginClassLoader;
-import co.aikar.util.LoadingMap;
 
-import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
 
 public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP =
-        Collections.synchronizedMap(LoadingMap.newHashMap(
-            new Function<TimingIdentifier, TimingHandler>() {
-                @Override
-                public TimingHandler apply(TimingIdentifier id) {
-                    return (id.protect ?
-                        new UnsafeTimingHandler(id) :
-                        new TimingHandler(id)
-                    );
-                }
-            },
-            256, .5F
-        ));
+    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = LoadingMap.of(
+        new ConcurrentHashMap<>(4096, .5F), id -> (id.protect ?
+            new UnsafeTimingHandler(id) :
+            new TimingHandler(id)
+        )
+    );
     public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
     public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
     public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
     public static List<String> hiddenConfigs = new ArrayList<String>();
     public static boolean privacy = false;
 
-    static final Collection<TimingHandler> HANDLERS = new ArrayDeque<TimingHandler>();
-    static final ArrayDeque<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayDeque<TimingHistory.MinuteReport>();
+    static final List<TimingHandler> HANDLERS = new ArrayList<>(1024);
+    static final List<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayList<>(64);
 
     static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
     static TimingHandler CURRENT;
diff --git a/src/main/java/co/aikar/util/LoadingMap.java b/src/main/java/co/aikar/util/LoadingMap.java
index 1474384e..9a4f9dca 100644
--- a/src/main/java/co/aikar/util/LoadingMap.java
+++ b/src/main/java/co/aikar/util/LoadingMap.java
@@ -23,20 +23,14 @@
  */
 package co.aikar.util;
 
-
-import com.google.common.base.Function;
-import org.bukkit.Material;
-import co.aikar.timings.TimingHistory;
-import org.w3c.dom.css.Counter;
-
 import java.lang.reflect.Constructor;
 import java.util.AbstractMap;
 import java.util.Collection;
-import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Function;
 
 /**
  * Allows you to pass a Loader function that when a key is accessed that doesn't exists,
@@ -53,16 +47,16 @@ import java.util.Set;
  * @param <K> Key
  * @param <V> Value
  */
-public class LoadingMap <K,V> extends AbstractMap<K, V> {
+public class LoadingMap <K, V> extends AbstractMap<K, V> {
     private final Map<K, V> backingMap;
-    private final Function<K, V> loader;
+    private final java.util.function.Function<K, V> loader;
 
     /**
      * Initializes an auto loading map using specified loader and backing map
      * @param backingMap Map to wrap
      * @param loader Loader
      */
-    public LoadingMap(Map<K, V> backingMap, Function<K, V> loader) {
+    public LoadingMap(Map<K, V> backingMap, java.util.function.Function<K, V> loader) {
         this.backingMap = backingMap;
         this.loader = loader;
     }
@@ -77,7 +71,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> of(Map<K, V> backingMap, Function<K, V> loader) {
-        return new LoadingMap<K, V>(backingMap, loader);
+        return new LoadingMap<>(backingMap, loader);
     }
 
     /**
@@ -97,7 +91,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      */
     public static <K, V> Map<K, V> newAutoMap(Map<K, V> backingMap, final Class<? extends K> keyClass,
                                               final Class<? extends V> valueClass) {
-        return new LoadingMap<K, V>(backingMap, new AutoInstantiatingLoader<K, V>(keyClass, valueClass));
+        return new LoadingMap<>(backingMap, new AutoInstantiatingLoader<>(keyClass, valueClass));
     }
     /**
      * Creates a LoadingMap with an auto instantiating loader.
@@ -130,7 +124,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map that auto instantiates on .get()
      */
     public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass) {
-        return newAutoMap(new HashMap<K, V>(), keyClass, valueClass);
+        return newAutoMap(new HashMap<>(), keyClass, valueClass);
     }
 
     /**
@@ -161,7 +155,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map that auto instantiates on .get()
      */
     public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
-        return newAutoMap(new HashMap<K, V>(initialCapacity, loadFactor), keyClass, valueClass);
+        return newAutoMap(new HashMap<>(initialCapacity, loadFactor), keyClass, valueClass);
     }
 
     /**
@@ -189,7 +183,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newHashMap(Function<K, V> loader) {
-        return new LoadingMap<K, V>(new HashMap<K, V>(), loader);
+        return new LoadingMap<>(new HashMap<>(), loader);
     }
 
     /**
@@ -197,13 +191,25 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      *
      * @param loader Loader to use
      * @param initialCapacity Initial capacity to use
+     * @param <K> Key Type of the Map
+     * @param <V> Value Type of the Map
+     * @return Map
+     */
+    public static <K, V> Map<K, V> newHashMap(Function<K, V> loader, int initialCapacity) {
+        return new LoadingMap<>(new HashMap<>(initialCapacity), loader);
+    }
+    /**
+     * Initializes an auto loading map using a HashMap
+     *
+     * @param loader Loader to use
+     * @param initialCapacity Initial capacity to use
      * @param loadFactor Load factor to use
      * @param <K> Key Type of the Map
      * @param <V> Value Type of the Map
      * @return Map
      */
     public static <K, V> Map<K, V> newHashMap(Function<K, V> loader, int initialCapacity, float loadFactor) {
-        return new LoadingMap<K, V>(new HashMap<K, V>(initialCapacity, loadFactor), loader);
+        return new LoadingMap<>(new HashMap<>(initialCapacity, loadFactor), loader);
     }
 
     /**
@@ -215,7 +221,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader) {
-        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(), loader);
+        return new LoadingMap<>(new IdentityHashMap<>(), loader);
     }
 
     /**
@@ -228,7 +234,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader, int initialCapacity) {
-        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(initialCapacity), loader);
+        return new LoadingMap<>(new IdentityHashMap<>(initialCapacity), loader);
     }
 
     @Override
@@ -245,14 +251,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
 
     @Override
     public V get(Object key) {
-        V res =  backingMap.get(key);
-        if (res == null && key != null) {
-            res = loader.apply((K) key);
-            if (res != null) {
-                backingMap.put((K) key, res);
-            }
-        }
-        return res;
+        return backingMap.computeIfAbsent((K) key, loader);
     }
 
     public V put(K key, V value) {return backingMap.put(key, value);}
@@ -283,7 +282,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
     }
 
     public LoadingMap<K, V> clone() {
-        return new LoadingMap<K, V>(backingMap, loader);
+        return new LoadingMap<>(backingMap, loader);
     }
 
     private static class AutoInstantiatingLoader<K, V> implements Function<K, V> {
diff --git a/src/main/java/org/bukkit/inventory/ShapedRecipe.java b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
index d7fa6d28..dbd187d3 100644
--- a/src/main/java/org/bukkit/inventory/ShapedRecipe.java
+++ b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
@@ -147,6 +147,10 @@ public class ShapedRecipe implements Recipe, Keyed {
         return result;
     }
 
+    public Map<Character, ItemStack> getIngredients() {
+        return ingredients;
+    }
+
     /**
      * Get the shape.
      *
diff --git a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
index f2dd46f2..a0801fd5 100644
--- a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
+++ b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
@@ -214,6 +214,10 @@ public class ShapelessRecipe implements Recipe, Keyed {
         return this;
     }
 
+    public List<ItemStack> getIngredients() {
+        return ingredients;
+    }
+
     /**
      * Get the result of this recipe.
      *
diff --git a/src/main/java/org/bukkit/map/MapCursorCollection.java b/src/main/java/org/bukkit/map/MapCursorCollection.java
index 1dc9025d..87ff6726 100644
--- a/src/main/java/org/bukkit/map/MapCursorCollection.java
+++ b/src/main/java/org/bukkit/map/MapCursorCollection.java
@@ -26,6 +26,10 @@ public final class MapCursorCollection {
      * @return The MapCursor.
      */
     public MapCursor getCursor(int index) {
+        if (cursors.isEmpty()) {
+            return null;
+        }
+
         return cursors.get(index);
     }
 
@@ -53,8 +57,8 @@ public final class MapCursorCollection {
     /**
      * Add a cursor to the collection.
      *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
+     * @param x         The x coordinate, from -128 to 127.
+     * @param y         The y coordinate, from -128 to 127.
      * @param direction The facing of the cursor, from 0 to 15.
      * @return The newly added MapCursor.
      */
@@ -65,10 +69,10 @@ public final class MapCursorCollection {
     /**
      * Add a cursor to the collection.
      *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
+     * @param x         The x coordinate, from -128 to 127.
+     * @param y         The y coordinate, from -128 to 127.
      * @param direction The facing of the cursor, from 0 to 15.
-     * @param type The type (color/style) of the map cursor.
+     * @param type      The type (color/style) of the map cursor.
      * @return The newly added MapCursor.
      * @deprecated Magic value
      */
@@ -80,11 +84,11 @@ public final class MapCursorCollection {
     /**
      * Add a cursor to the collection.
      *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
+     * @param x         The x coordinate, from -128 to 127.
+     * @param y         The y coordinate, from -128 to 127.
      * @param direction The facing of the cursor, from 0 to 15.
-     * @param type The type (color/style) of the map cursor.
-     * @param visible Whether the cursor is visible.
+     * @param type      The type (color/style) of the map cursor.
+     * @param visible   Whether the cursor is visible.
      * @return The newly added MapCursor.
      * @deprecated Magic value
      */
-- 
2.13.3.windows.1

